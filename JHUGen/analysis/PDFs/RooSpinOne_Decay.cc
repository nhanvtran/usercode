/***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

#include "Riostream.h" 
#include "RooSpinOne_Decay.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

using namespace TMath;

// ClassImp(RooSpinOne_Decay) 
  
  RooSpinOne_Decay::RooSpinOne_Decay(const char *name, const char *title, 
			       RooAbsReal& _mzz,
			       RooAbsReal& _m1,
			       RooAbsReal& _m2,
			       RooAbsReal& _h1,
			       RooAbsReal& _h2,
			       RooAbsReal& _Phi,
			       RooAbsReal& _g1Val,
			       RooAbsReal& _g2Val,
			       RooAbsReal& _R1Val,
			       RooAbsReal& _R2Val,
			       RooAbsReal& _aParam,
			       RooAbsReal& _mZ,
			       RooAbsReal& _gamZ) :
    RooAbsPdf(name,title), 
    mzz("mzz","mzz",this,_mzz),
    m1("m1","m1",this,_m1),
    m2("m2","m2",this,_m2),
    h1("h1","h1",this,_h1),
    h2("h2","h2",this,_h2),
    Phi("Phi","Phi",this,_Phi),
    g1Val("g1Val","g1Val",this,_g1Val),
    g2Val("g2Val","g2Val",this,_g2Val),
    R1Val("R1Val","R1Val",this,_R1Val),
    R2Val("R2Val","R2Val",this,_R2Val),
    aParam("aParam","aParam",this,_aParam),
    mZ("mZ","mZ",this,_mZ),
    gamZ("gamZ","gamZ",this,_gamZ)
{ 
} 


RooSpinOne_Decay::RooSpinOne_Decay(const RooSpinOne_Decay& other, const char* name) :  
  RooAbsPdf(other,name), 
  mzz("mzz",this,other.mzz),
  m1("m1",this,other.m1),
  m2("m2",this,other.m2),
  h1("h1",this,other.h1),
  h2("h2",this,other.h2),
  Phi("Phi",this,other.Phi),
  g1Val("g1Val",this,other.g1Val),
  g2Val("g2Val",this,other.g2Val),
  R1Val("R1Val",this,other.R1Val),
  R2Val("R2Val",this,other.R2Val),
  aParam("aParam",this,other.aParam),
  mZ("mZ",this,other.mZ),
  gamZ("gamZ",this,other.gamZ)
{ 
} 



Double_t RooSpinOne_Decay::evaluate() const 
{ 
  
  
  bool isZZ = true;
  if ( mZ < 90.) isZZ = false;
  if ( isZZ ) {
    if( (m1+m2) > mzz || m2>m1 ) return 1e-9; 
  } else {
    if( (m1+m2) > mzz ) return 1e-9; 
  }
  double nanval = sqrt((1 - TMath::Power(m1 - m2,2)/TMath::Power(mzz,2))*(1 - TMath::Power(m1 + m2,2)/TMath::Power(mzz,2)));
  if (nanval != nanval) return 1e-9;
  
  //-----------------------------------------------------------------------
  // propagator
  //-----------------------------------------------------------------------
  
  Double_t betaValSquared = (1.-(pow(m1-m2,2)/pow(mzz,2)))*(1.-(pow(m1+m2,2)/pow(mzz,2)));
  Double_t betaVal = sqrt(betaValSquared);
  
  Double_t term1Coeff = (pow(m1,3))/( (pow(m1,2)-pow(mZ,2))*(pow(m1,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );
  Double_t term2Coeff = (pow(m2,3))/( (pow(m2,2)-pow(mZ,2))*(pow(m2,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );
  
  //-----------------------------------------------------------------------
  // Helicity Amplitudes
  //-----------------------------------------------------------------------
  
  // calculating the angular parameters from the coupling constants 
  // See http://www.pha.jhu.edu/~gritsan/FORM/result_spin1.txt
  Double_t x = (mzz*mzz-m1*m1-m2*m2)/(2.0*m1*m2);

  Double_t f00Real =  TMath::Power(mzz,-1)*g1Val*( sqrt(x*x-1) )*(m1*m1-m2*m2); 
  Double_t f00Imag =  0.;

  Double_t fppReal = 0.;
  Double_t fppImag = TMath::Power(mzz,-1)*g2Val*(m1*m1-m2*m2); 

  Double_t fmmReal = 0.;
  Double_t fmmImag = -1. * fppImag;


  Double_t fp0Real =  m1*g1Val * ( sqrt(x*x-1) ); 
  Double_t fp0Imag =  Power(mzz,-2.)*Power(m2,3)*g2Val * (  - 1./2. )
    + Power(mzz,-2.)*m1*m1*m2*g2Val * ( 1 + 2*(x*x-1) )
    + Power(mzz,-2.)*Power(m1,4)*Power(m2,-1)*g2Val * (  - 1./2. )
    + m2*g2Val * (  - 1./2. )
    + m1*m1*Power(m2,-1)*g2Val * ( 1./2. );


  Double_t f0pReal = m2*g1Val * (  - sqrt(x*x-1) );
  Double_t f0pImag = Power(mzz,-2.)*Power(m1,-1)*Power(m2,4)*g2Val * ( 1./2. )
    + Power(mzz,-2.)*m1*Power(m2,2)*g2Val * (  - 1 - 2*(x*x-1) )
    + Power(mzz,-2.)*Power(m1,3)*g2Val * ( 1./2. )
    + Power(m1,-1)*Power(m2,2)*g2Val * (  - 1./2. )
    + m1*g2Val * ( 1./2. );
  
  Double_t f0mReal =  m2*g1Val * (  - sqrt(x*x-1) );
  Double_t f0mImag =  Power(mzz,-2.)*Power(m1,-1)*Power(m2,4)*g2Val * (  - 1./2. )
    + Power(mzz,-2.)*m1*Power(m2,2)*g2Val * ( 1 + 2*(x*x-1) )
    + Power(mzz,-2.)*Power(m1,3)*g2Val * (  - 1./2. )
    + Power(m1,-1)*Power(m2,2)*g2Val * ( 1./2. )
    + m1*g2Val * (  - 1./2. );
  
  Double_t fm0Real =  m1*g1Val * ( sqrt(x*x-1) ); 
  Double_t fm0Imag = Power(mzz,-2.)*Power(m2,3)*g2Val * ( 1./2. )
    + Power(mzz,-2.)*m1*m1*m2*g2Val * (  - 1 - 2*(x*x-1) )
    + Power(mzz,-2.)*Power(m1,4)*Power(m2,-1)*g2Val * ( 1./2. )
    + m2*g2Val * ( 1./2. )
    + m1*m1*Power(m2,-1)*g2Val * (  - 1./2. );
  
  Double_t f00 = f00Imag*f00Imag + f00Real*f00Real;
  Double_t fpp = fppImag*fppImag + fppReal*fppReal;
  Double_t fmm = fmmImag*fmmImag + fmmReal*fmmReal;
  Double_t fp0 = fp0Imag*fp0Imag + fp0Real*fp0Real;
  Double_t f0p = f0pImag*f0pImag + f0pReal*f0pReal;
  Double_t fm0 = fm0Imag*fm0Imag + fm0Real*fm0Real;
  Double_t f0m = f0mImag*f0mImag + f0mReal*f0mReal;

  Double_t phi00=atan2(f00Imag,f00Real);
  Double_t phipp=atan2(fppImag,fppReal)-phi00;
  Double_t phimm=atan2(fmmImag,fmmReal)-phi00;
  Double_t phip0=atan2(fp0Imag,fp0Real)-phi00;
  Double_t phi0p=atan2(f0pImag,f0pReal)-phi00;
  Double_t phim0=atan2(fm0Imag,fm0Real)-phi00;
  Double_t phi0m=atan2(f0mImag,f0mReal)-phi00;

  Double_t value=0;

  value += (f00*(-1 + TMath::Power(h1,2))*(-1 + TMath::Power(h2,2))*TMath::Pi())/3.; 
  value += (fmm*TMath::Pi()*(1 + TMath::Power(h1,2) - 2*h1*R1Val)*(1 + TMath::Power(h2,2) - 2*h2*R2Val))/12.;
  value += (fpp*TMath::Pi()*(1 + TMath::Power(h1,2) + 2*h1*R1Val)*(1 + TMath::Power(h2,2) + 2*h2*R2Val))/12.;
  value += -(fp0*(-1 + TMath::Power(h2,2))*TMath::Pi()*(1 + TMath::Power(h1,2) + 2*h1*R1Val))/6.;
  value += -(f0m*(-1 + TMath::Power(h1,2))*TMath::Pi()*(1 + TMath::Power(h2,2) - 2*h2*R2Val))/6.;
  value += -(f0p*(-1 + TMath::Power(h1,2))*TMath::Pi()*(1 + TMath::Power(h2,2) + 2*h2*R2Val))/6.;
  value += -(fm0*(-1 + TMath::Power(h2,2))*TMath::Pi()*(1 + TMath::Power(h1,2) - 2*h1*R1Val))/6.;
  value += (Sqrt(f00)*Sqrt(fmm)*Sqrt(1 - TMath::Power(h1,2))*Sqrt(1 - TMath::Power(h2,2))*TMath::Pi()*(h1 - R1Val)*(h2 - R2Val)*Cos(phimm - Phi))/3.;
  value += (Sqrt(f00)*Sqrt(fpp)*Sqrt(1 - TMath::Power(h1,2))*Sqrt(1 - TMath::Power(h2,2))*TMath::Pi()*(h1 + R1Val)*(h2 + R2Val)*Cos(phipp + Phi))/3.;
  value += (Sqrt(fmm)*Sqrt(fpp)*(-1 + TMath::Power(h1,2))*(-1 + TMath::Power(h2,2))*TMath::Pi()*Cos(phimm - phipp - 2*Phi))/6.;
  value += -(Sqrt(f0m)*Sqrt(fp0)*Sqrt(1 - TMath::Power(h1,2))*Sqrt(1 - TMath::Power(h2,2))*TMath::Pi()*(h1 + R1Val)*(h2 - R2Val)*Cos(phi0m - phip0 - Phi))/3.;
  value += -(Sqrt(f0p)*Sqrt(fm0)*Sqrt(1 - TMath::Power(h1,2))*Sqrt(1 - TMath::Power(h2,2))*TMath::Pi()*(h1 - R1Val)*(h2 + R2Val)*Cos(phi0p - phim0 + Phi))/3.;

  return value*term1Coeff*term2Coeff*betaVal;
  
} 

Int_t RooSpinOne_Decay::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
  if (matchArgs(allVars,analVars,RooArgSet(*h1.absArg(),*h2.absArg(),*Phi.absArg()))) return 4 ;
  if (matchArgs(allVars,analVars,h1,h2)) return 3 ;
  if (matchArgs(allVars,analVars,h1,Phi)) return 2 ;
  if (matchArgs(allVars,analVars,h2,Phi)) return 1 ;
  return 0 ;
}

Double_t RooSpinOne_Decay::analyticalIntegral(Int_t code, const char* rangeName) const
{
  
  bool isZZ = true;
  if ( mZ < 90.) isZZ = false;
  if ( isZZ ) {
    if( (m1+m2) > mzz || m2>m1 ) return 1e-9; 
  } else {
    if( (m1+m2) > mzz ) return 1e-9; 
  }
  double nanval = sqrt((1 - TMath::Power(m1 - m2,2)/TMath::Power(mzz,2))*(1 - TMath::Power(m1 + m2,2)/TMath::Power(mzz,2)));
  if (nanval != nanval) return 1e-9;
  
  //-----------------------------------------------------------------------
  // propagator
  //-----------------------------------------------------------------------
  
  Double_t betaValSquared = (1.-(pow(m1-m2,2)/pow(mzz,2)))*(1.-(pow(m1+m2,2)/pow(mzz,2)));
  Double_t betaVal = sqrt(betaValSquared);
  
  Double_t term1Coeff = (pow(m1,3))/( (pow(m1,2)-pow(mZ,2))*(pow(m1,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );
  Double_t term2Coeff = (pow(m2,3))/( (pow(m2,2)-pow(mZ,2))*(pow(m2,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );
  
  //-----------------------------------------------------------------------
  // Helicity Amplitudes
  //-----------------------------------------------------------------------
  // calculating the angular parameters from the coupling constants 
  // See http://www.pha.jhu.edu/~gritsan/FORM/result_spin1.txt
  
  Double_t x = (mzz*mzz-m1*m1-m2*m2)/(2.0*m1*m2);

  Double_t f00Real =  TMath::Power(mzz,-1)*g1Val*( sqrt(x*x-1) )*(m1*m1-m2*m2); 
  Double_t f00Imag =  0.;

  Double_t fppReal = 0.;
  Double_t fppImag = TMath::Power(mzz,-1)*g2Val*(m1*m1-m2*m2); 

  Double_t fmmReal = 0.;
  Double_t fmmImag = -1. * fppImag;


  Double_t fp0Real =  m1*g1Val * ( sqrt(x*x-1) ); 
  Double_t fp0Imag =  Power(mzz,-2.)*Power(m2,3)*g2Val * (  - 1./2. )
    + Power(mzz,-2.)*m1*m1*m2*g2Val * ( 1 + 2*(x*x-1) )
    + Power(mzz,-2.)*Power(m1,4)*Power(m2,-1)*g2Val * (  - 1./2. )
    + m2*g2Val * (  - 1./2. )
    + m1*m1*Power(m2,-1)*g2Val * ( 1./2. );


  Double_t f0pReal = m2*g1Val * (  - sqrt(x*x-1) );
  Double_t f0pImag = Power(mzz,-2.)*Power(m1,-1)*Power(m2,4)*g2Val * ( 1./2. )
    + Power(mzz,-2.)*m1*Power(m2,2)*g2Val * (  - 1 - 2*(x*x-1) )
    + Power(mzz,-2.)*Power(m1,3)*g2Val * ( 1./2. )
    + Power(m1,-1)*Power(m2,2)*g2Val * (  - 1./2. )
    + m1*g2Val * ( 1./2. );
  
  Double_t f0mReal =  m2*g1Val * (  - sqrt(x*x-1) );
  Double_t f0mImag =  Power(mzz,-2.)*Power(m1,-1)*Power(m2,4)*g2Val * (  - 1./2. )
    + Power(mzz,-2.)*m1*Power(m2,2)*g2Val * ( 1 + 2*(x*x-1) )
    + Power(mzz,-2.)*Power(m1,3)*g2Val * (  - 1./2. )
    + Power(m1,-1)*Power(m2,2)*g2Val * ( 1./2. )
    + m1*g2Val * (  - 1./2. );
  
  Double_t fm0Real =  m1*g1Val * ( sqrt(x*x-1) ); 
  Double_t fm0Imag = Power(mzz,-2.)*Power(m2,3)*g2Val * ( 1./2. )
    + Power(mzz,-2.)*m1*m1*m2*g2Val * (  - 1 - 2*(x*x-1) )
    + Power(mzz,-2.)*Power(m1,4)*Power(m2,-1)*g2Val * ( 1./2. )
    + m2*g2Val * ( 1./2. )
    + m1*m1*Power(m2,-1)*g2Val * (  - 1./2. );
  
  Double_t f00 = f00Imag*f00Imag + f00Real*f00Real;
  Double_t fpp = fppImag*fppImag + fppReal*fppReal;
  Double_t fmm = fmmImag*fmmImag + fmmReal*fmmReal;
  Double_t fp0 = fp0Imag*fp0Imag + fp0Real*fp0Real;
  Double_t f0p = f0pImag*f0pImag + f0pReal*f0pReal;
  Double_t fm0 = fm0Imag*fm0Imag + fm0Real*fm0Real;
  Double_t f0m = f0mImag*f0mImag + f0mReal*f0mReal;
  
  Double_t phi00=atan2(f00Imag,f00Real);
  Double_t phipp=atan2(fppImag,fppReal)-phi00;
  Double_t phimm=atan2(fmmImag,fmmReal)-phi00;
  Double_t phip0=atan2(fp0Imag,fp0Real)-phi00;
  Double_t phi0p=atan2(f0pImag,f0pReal)-phi00;
  Double_t phim0=atan2(fm0Imag,fm0Real)-phi00;
  Double_t phi0m=atan2(f0mImag,f0mReal)-phi00;

  Double_t integral=0;

  switch(code)
    {
      // Integrate out all angles
    case 4:
      {
	integral = 0.;
	integral+= 
	  (32.*f00*TMath::Power(Pi(),2))/27.;
	integral+= 
	  (32.*fpp*TMath::Power(Pi(),2))/27.;
	integral+= 
	  (32.*fmm*TMath::Power(Pi(),2))/27.;
	integral+= 
	  (32.*fp0*TMath::Power(Pi(),2))/27.;
	integral+= 
	  (32.*f0m*TMath::Power(Pi(),2))/27.;
	integral+= 
	  (32.*f0p*TMath::Power(Pi(),2))/27.;
	integral+= 
	  (32.*fm0*TMath::Power(Pi(),2))/27.;
	return term1Coeff*term2Coeff*betaVal*integral;

      }
      
     // projection to Phi, integrate all other angles
    case 3:
      {
	integral = 0.;
	integral += 
	  (16*f00*Pi())/27.;
	integral += 
	  (16*fmm*Pi())/27.;
	integral += 
	  (16*fpp*Pi())/27.;
	integral += 
	  (16*fp0*Pi())/27.;
	integral += 
	  (16*f0m*Pi())/27.;
	integral += 
	  (16*f0p*Pi())/27.;
	integral += 
	  (16*fm0*Pi())/27.;
	integral +=
	  (Sqrt(f00)*Sqrt(fmm)*TMath::Power(TMath::Pi(),3)*R1Val*R2Val*Cos(Phi - phimm))/12.;
	integral +=
	  (Sqrt(f00)*Sqrt(fpp)*TMath::Power(TMath::Pi(),3)*R1Val*R2Val*Cos(Phi + phipp))/12.;
	integral += 
	  (8*Sqrt(fmm)*Sqrt(fpp)*TMath::Pi()*Cos(2*Phi - phimm + phipp))/27.;
	integral += 
	  (Sqrt(f0m)*Sqrt(fp0)*TMath::Power(Pi(),3)*R1Val*R2Val*
	   Cos(Phi - phi0m + phip0))/12.;
	integral +=
	  (Sqrt(f0p)*Sqrt(fm0)*TMath::Power(Pi(),3)*R1Val*R2Val*
		Cos(Phi + phi0p - phim0))/12.;
	return term1Coeff*term2Coeff*betaVal*integral;
      }
      
      // projections to h2, integrate over all others
    case 2:
      {
	integral = 0.;
	integral +=
	  (-8*f00*(-1 + TMath::Power(h2,2))*TMath::Power(TMath::Pi(),2))/9.;
	integral +=
	  (4*fmm*TMath::Power(TMath::Pi(),2)*(1 + TMath::Power(h2,2) - 2*h2*R2Val))/9.;
	integral +=
	  (4*fpp*TMath::Power(TMath::Pi(),2)*(1 + TMath::Power(h2,2) + 2*h2*R2Val))/9.;
	integral += 
	  (-8*fp0*(-1 + TMath::Power(h2,2))*TMath::Power(TMath::Pi(),2))/9.;
	integral += 
	  (4*f0m*TMath::Power(TMath::Pi(),2)*(1 + TMath::Power(h2,2) - 2*h2*R2Val))/9.;
	integral += 
	  (4*f0p*TMath::Power(TMath::Pi(),2)*(1 + TMath::Power(h2,2) + 2*h2*R2Val))/9.;
	integral += 
	  (-8*fm0*(-1 + TMath::Power(h2,2))*TMath::Power(TMath::Pi(),2))/9.;
	return term1Coeff*term2Coeff*betaVal*integral;
   }
      // projections to h1, integrate all others
    case 1:
      {
	integral=0.;
	integral +=
	  (-8*f00*(-1 + TMath::Power(h1,2))*TMath::Power(TMath::Pi(),2))/9.;
	integral +=
	  (4*fmm*TMath::Power(TMath::Pi(),2)*(1 + TMath::Power(h1,2) - 2*h1*R1Val))/9.;
	integral +=
	  (4*fpp*TMath::Power(TMath::Pi(),2)*(1 + TMath::Power(h1,2) + 2*h1*R1Val))/9.;
	integral += 
	  (4*fp0*TMath::Power(TMath::Pi(),2)*(1 + TMath::Power(h1,2) + 2*h1*R1Val))/9.;
	integral += 
	  (-8*f0m*(-1 + TMath::Power(h1,2))*TMath::Power(TMath::Pi(),2))/9.;
	integral += 
	  (-8*f0p*(-1 + TMath::Power(h1,2))*TMath::Power(TMath::Pi(),2))/9.;
	integral += 
	  (4*fm0*TMath::Power(TMath::Pi(),2)*(1 + TMath::Power(h1,2) - 2*h1*R1Val))/9.;
	return term1Coeff*term2Coeff*betaVal*integral;	
      }
    }
  assert(0) ;
  return 0 ;
}
