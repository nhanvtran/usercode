/*****************************************************************************
* Project: RooFit                                                           *
*                                                                           *
* This code was autogenerated by RooClassFactory                            *
*****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooSpinTwo_Decay.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

//ClassImp(RooSpinTwo_Decay)

RooSpinTwo_Decay::RooSpinTwo_Decay(const char *name, const char *title,
RooAbsReal& _mzz,
RooAbsReal& _m1,
RooAbsReal& _m2,
RooAbsReal& _h1,
RooAbsReal& _h2,
RooAbsReal& _Phi,
RooAbsReal& _c1Val,
RooAbsReal& _c2Val,
RooAbsReal& _c3Val,
RooAbsReal& _c4Val,
RooAbsReal& _c5Val,
RooAbsReal& _c6Val,
RooAbsReal& _c7Val,
RooAbsReal& _useGTerm,
RooAbsReal& _g1Val,
RooAbsReal& _g2Val,
RooAbsReal& _g3Val,
RooAbsReal& _g4Val,
RooAbsReal& _g5Val,
RooAbsReal& _g6Val,
RooAbsReal& _g7Val,
RooAbsReal& _g8Val,
RooAbsReal& _g9Val,
RooAbsReal& _g10Val,
RooAbsReal& _fz1Val,
RooAbsReal& _fz2Val,
RooAbsReal& _R1Val,
RooAbsReal& _R2Val,
RooAbsReal& _mZ,
RooAbsReal& _gamZ) :
RooAbsPdf(name,title),
mzz("mzz","mzz",this,_mzz),
m1("m1","m1",this,_m1),
m2("m2","m2",this,_m2),
h1("h1","h1",this,_h1),
h2("h2","h2",this,_h2),
Phi("Phi","Phi",this,_Phi),
c1Val("c1Val","c1Val",this,_c1Val),
c2Val("c2Val","c2Val",this,_c2Val),
c3Val("c3Val","c3Val",this,_c3Val),
c4Val("c4Val","c4Val",this,_c4Val),
c5Val("c5Val","c5Val",this,_c5Val),
c6Val("c6Val","c6Val",this,_c6Val),
c7Val("c7Val","c7Val",this,_c7Val),
useGTerm("useGTerm","useGTerm",this,_useGTerm),
g1Val("g1Val","g1Val",this,_g1Val),
g2Val("g2Val","g2Val",this,_g2Val),
g3Val("g3Val","g3Val",this,_g3Val),
g4Val("g4Val","g4Val",this,_g4Val),
g5Val("g5Val","g5Val",this,_g5Val),
g6Val("g6Val","g6Val",this,_g6Val),
g7Val("g7Val","g7Val",this,_g7Val),
g8Val("g8Val","g8Val",this,_g8Val),
g9Val("g9Val","g9Val",this,_g9Val),
g10Val("g10Val","g10Val",this,_g10Val),
fz1Val("fz1Val","fz1Val",this,_fz1Val),
fz2Val("fz2Val","fz2Val",this,_fz2Val),
R1Val("R1Val","R1Val",this,_R1Val),
R2Val("R2Val","R2Val",this,_R2Val),
mZ("mZ","mZ",this,_mZ),
gamZ("gamZ","gamZ",this,_gamZ)
{
}


RooSpinTwo_Decay::RooSpinTwo_Decay(const RooSpinTwo_Decay& other, const char* name) :
RooAbsPdf(other,name),
mzz("mzz",this,other.mzz),
m1("m1",this,other.m1),
m2("m2",this,other.m2),
h1("h1",this,other.h1),
h2("h2",this,other.h2),
Phi("Phi",this,other.Phi),
c1Val("c1Val",this,other.c1Val),
c2Val("c2Val",this,other.c2Val),
c3Val("c3Val",this,other.c3Val),
c4Val("c4Val",this,other.c4Val),
c5Val("c5Val",this,other.c5Val),
c6Val("c6Val",this,other.c6Val),
c7Val("c7Val",this,other.c7Val),
useGTerm("useGTerm",this,other.useGTerm),
g1Val("g1Val",this,other.g1Val),
g2Val("g2Val",this,other.g2Val),
g3Val("g3Val",this,other.g3Val),
g4Val("g4Val",this,other.g4Val),
g5Val("g5Val",this,other.g5Val),
g6Val("g6Val",this,other.g6Val),
g7Val("g7Val",this,other.g7Val),
g8Val("g8Val",this,other.g8Val),
g9Val("g9Val",this,other.g9Val),
g10Val("g10Val",this,other.g10Val),
fz1Val("fz1Val",this,other.fz1Val),
fz2Val("fz2Val",this,other.fz2Val),
R1Val("R1Val",this,other.R1Val),
R2Val("R2Val",this,other.R2Val),
mZ("mZ",this,other.mZ),
gamZ("gamZ",this,other.gamZ)
{
}



Double_t RooSpinTwo_Decay::evaluate() const
{
bool isZZ = true;
if ( mZ < 90.) isZZ = false;
if ( isZZ ) {
if( (m1+m2) > mzz || m2>m1 ) return 1e-9;
} else {
if( (m1+m2) > mzz ) return 1e-9;
}
double nanval = sqrt((1 - TMath::Power(m1 - m2,2)/TMath::Power(mzz,2))*(1 - TMath::Power(m1 + m2,2)/TMath::Power(mzz,2)));
if (nanval != nanval) return 1e-9;

// set the c1->c7 terms directly from the inputs
double c1 = c1Val;
double c2 = c2Val;
double c3 = c3Val;
double c4 = c4Val;
double c5 = c5Val;
double c6 = c6Val;
double c7 = c7Val;

// calculate the c1->c7 from g
if ( useGTerm > 0. ) {
double Lambda = 1000.; // the new physics cutoff
double s = (mzz*mzz-m1*m1-m2*m2)/2.;
double kappa =  s / (Lambda*Lambda);
c1 = 2*g1Val + 2*g2Val*kappa*pow((1+mZ*mZ/s),2) + 2*g5Val*(mZ*mZ)/s;
c2 = -0.5*g1Val + g3Val*kappa*(1-mZ*mZ/s) + 2*g4Val*kappa + g7Val*kappa*mZ*mZ/s;
c3 = -1.0*(g2Val/2.0+g3Val+2.0*g4Val)*kappa*mzz*mzz/s;
c4 = -g1Val - g2Val*kappa - (g2Val+g3Val+g6Val)*kappa*(mZ*mZ/s);
c5 = 2*g8Val*kappa*(mzz*mzz)/s;
c6 = g9Val;
c7 = g10Val*kappa*(mzz*mzz)/s;
}

Double_t value=0;
Double_t fz0Val=1-fz1Val-fz2Val;

Double_t x = (mzz*mzz-m1*m1-m2*m2)/(2.0*m1*m2);

//-----------------------------------------------------------------------
// propagator
//-----------------------------------------------------------------------

Double_t betaValSquared = (1.-(pow(m1-m2,2)/pow(mzz,2)))*(1.-(pow(m1+m2,2)/pow(mzz,2)));
Double_t betaVal = sqrt(betaValSquared);

Double_t term1Coeff = (pow(m1,3))/( (pow(m1,2)-pow(mZ,2))*(pow(m1,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );
Double_t term2Coeff = (pow(m2,3))/( (pow(m2,2)-pow(mZ,2))*(pow(m2,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );

//-----------------------------------------------------------------------
// amplitudes
// See http://www.pha.jhu.edu/~gritsan/FORM/result_spin2.txt
// -----------------------------------------------------------------------

Double_t f00Real =
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*pow(m1,3)*pow(m2,3) * ( 3./4. + (x*x-1.) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c2*pow(m1,3)*pow(m2,3) * (  - 4.*(x*x-1.) - 8*pow(x*x-1.,2) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c3*pow(m1,3)*pow(m2,3) * (  - 8.*pow(x*x-1.,2) )

+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*m1*pow(m2,5) * (  - 1.0/2.0 - 1.0/2.0*(x*x-1.) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c2*m1*pow(m2,5) * ( 2.*(x*x-1.) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*pow(m1,5)*m2 * (  - 1.0/2.0 - 1.0/2.0*(x*x-1.) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c2*pow(m1,5)*m2 * ( 2.*(x*x-1.) )

+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*(1.0/m1)*pow(m2,7) * ( 1.0/8.0 )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*pow(m1,7)*(1.0/m2) * ( 1.0/8.0 )

+ pow(sqrt(6.),-1)*c1*m1*m2 * ( 1.0/2.0 + 1.0/2.0*(x*x-1.) )
+ pow(sqrt(6.),-1)*c2*m1*m2 * (  - 2.*(x*x-1.) )
+ pow(sqrt(6.),-1)*c4*m1*m2 * ( 4.*(x*x-1.) )

+ pow(sqrt(6.),-1)*c1*(1.0/m1)*pow(m2,3) * (  - 1.0/4.0 )
+ pow(sqrt(6.),-1)*c1*pow(m1,3)*(1.0/m2) * (  - 1.0/4.0 )

+ pow(mzz,4)*pow(sqrt(6.),-1)*c1*(1.0/m1)*(1.0/m2) * ( 1.0/8.0 );


Double_t f00Imag = 0.;

//-----------------------------------------------------------------------
Double_t fppReal =
+ pow(mzz,2)*pow(sqrt(6.),-1)*c1 * ( 1./4. )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m2,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m1,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m1,2)*pow(m2,2) * ( 1.0/2.0 + (x*x-1.) )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c2*pow(m1,2)*pow(m2,2) * ( 8.*(x*x-1.) );

Double_t fppImag =

+ 1*pow(mzz,-4)*pow(sqrt(6.),-1)*c5*pow(m1,3)*pow(m2,3) * ( 8.*pow(sqrt(x*x-1.),3) )

+ 1*pow(sqrt(6.),-1)*c6*m1*m2 * (  - 4.*sqrt(x*x-1.) );

//-----------------------------------------------------------------------
Double_t fmmReal =
+ pow(mzz,2)*pow(sqrt(6.),-1)*c1 * ( 1.0/4.0 )

+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m1,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m2,4) * (  - 1.0/4.0 )

+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m1,2)*pow(m2,2) * ( 1.0/2.0 + (x*x-1.) )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c2*pow(m1,2)*pow(m2,2) * ( 8.*(x*x-1.) );

Double_t fmmImag =

+ pow(mzz,-4)*pow(sqrt(6.),-1)*c5*pow(m1,3)*pow(m2,3) * (  - 8.*pow(sqrt(x*x-1.),3) )

+ pow(sqrt(6.),-1)*c6*m1*m2 * ( 4.*sqrt(x*x-1.) );

//-----------------------------------------------------------------------

Double_t fp0Real =

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m2,5) * (  - 1.0/8.0 )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,2)*pow(m2,3) * ( 3.0/8.0 + 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,4)*m2 * (  - 3.0/8.0 - 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,6)*(1.0/m2) * ( 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,2)*m2 * ( 1.0/4.0 + 1.0/2.0*(x*x-1.) )
+ (1.0/mzz)*(1.0/sqrt(2.))*c4*pow(m1,2)*m2 * ( 2.*(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m2,3) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,4)*(1.0/m2) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*m2 * ( 1.0/8.0 )

+ mzz*(1.0/sqrt(2))*c1*pow(m1,2)*(1.0/m2) * (  - 1.0/8.0 )

+ pow(mzz,3)*(1.0/sqrt(2))*c1*(1.0/m2) * ( 1.0/8.0 );

Double_t fp0Imag =

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*pow(m1,3)*pow(m2,2) * (  - 4.*pow(sqrt(x*x-1.),3)*c7 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c6*m1*pow(m2,2) * (  - sqrt(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m1,3) * ( sqrt(x*x-1.) )

+ mzz*(1.0/sqrt(2.))*c6*m1 * (  - sqrt(x*x-1.) );



//-----------------------------------------------------------------------
Double_t f0pReal =
+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,6) * ( 1.0/8.0 )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*m1*pow(m2,4) * (  - 3.0/8.0 - 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,3)*pow(m2,2) * ( 3.0/8.0 + 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,5) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*m1*pow(m2,2) * ( 1.0/4.0 + 1.0/2.0*(x*x-1.) )
+ (1.0/mzz)*(1.0/sqrt(2.))*c4*m1*pow(m2,2) * ( 2.*(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,4) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,3) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,2) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*m1 * ( 1.0/8.0 )

+ pow(mzz,3)*(1.0/sqrt(2.))*c1*(1.0/m1) * ( 1.0/8.0 );

Double_t f0pImag =

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*pow(m1,2)*pow(m2,3) * (  - 4.*pow(sqrt(x*x-1.),3)*c7 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m2,3) * ( sqrt(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m1,2)*m2 * (  - sqrt(x*x-1.) )

+ mzz*(1.0/sqrt(2.))*c6*m2 * (  - sqrt(x*x-1.) );

//-----------------------------------------------------------------------


Double_t f0mReal =
+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,6) * ( 1.0/8.0 )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*m1*pow(m2,4) * (  - 3.0/8.0 - 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,3)*pow(m2,2) * ( 3.0/8.0 + 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,5) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*m1*pow(m2,2) * ( 1.0/4.0 + 1.0/2.0*(x*x-1.) )
+ (1.0/mzz)*(1.0/sqrt(2.))*c4*m1*pow(m2,2) * ( 2*(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,4) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,3) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,2) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*m1 * ( 1.0/8.0 )

+ pow(mzz,3)*(1.0/sqrt(2.))*c1*(1.0/m1) * ( 1.0/8.0 );

Double_t f0mImag =

+ 1*(1.0/pow(mzz,3))*(1.0/sqrt(2.))*pow(m1,2)*pow(m2,3) * ( 4*pow(sqrt(x*x-1.),3)*c7 )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m2,3) * (  - sqrt(x*x-1.) )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m1,2)*m2 * ( sqrt(x*x-1.) )

+ 1*mzz*(1.0/sqrt(2.))*c6*m2 * ( sqrt(x*x-1.) );

//-----------------------------------------------------------------------

Double_t fm0Real =
+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m2,5) * (  - 1.0/8.0 )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,2)*pow(m2,3) * ( 3.0/8.0 + 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,4)*m2 * (  - 3.0/8.0 - 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,6)*(1.0/m2) * ( 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,2)*m2 * ( 1.0/4.0 + 1.0/2.0*(x*x-1.) )
+ (1.0/mzz)*(1.0/sqrt(2.))*c4*pow(m1,2)*m2 * ( 2*(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m2,3) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,4)*(1.0/m2) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*m2 * ( 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*pow(m1,2)*(1.0/m2) * (  - 1.0/8.0 )

+ pow(mzz,3)*(1.0/sqrt(2.))*c1*(1.0/m2) * ( 1.0/8.0 );

Double_t fm0Imag =

+ 1*(1.0/pow(mzz,3))*(1.0/sqrt(2.))*pow(m1,3)*pow(m2,2) * ( 4*pow(sqrt(x*x-1.),3)*c7 )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*m1*pow(m2,2) * ( sqrt(x*x-1.) )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m1,3) * (  - sqrt(x*x-1.) )

+ 1*mzz*(1.0/sqrt(2.))*c6*m1 * ( sqrt(x*x-1.) );

//-----------------------------------------------------------------------
Double_t fpmReal =
+ pow(mzz,-2)*c1*pow(m1,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*c1*pow(m2,4) * (  - 1.0/4.0 )

+ pow(mzz,-2)*c1*pow(m1,2)*pow(m2,2) * ( 1.0/2.0 + (x*x-1.) )

+ pow(mzz,2)*c1 * ( 1.0/4.0 );

Double_t fpmImag = 0;

//-----------------------------------------------------------------------

Double_t fmpReal =
+ pow(mzz,-2)*c1*pow(m2,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*c1*pow(m1,4) * (  - 1.0/4.0 )

+ pow(mzz,-2)*c1*pow(m1,2)*pow(m2,2) * ( 1.0/2.0 + (x*x-1.) )

+ pow(mzz,2)*c1 * ( 1.0/4.0 );

Double_t fmpImag = 0;

//-----------------------------------------------------------------------
Double_t f00 = f00Imag*f00Imag + f00Real*f00Real;
Double_t fpp = fppImag*fppImag + fppReal*fppReal;
Double_t fmm = fmmImag*fmmImag + fmmReal*fmmReal;
Double_t fp0 = fp0Imag*fp0Imag + fp0Real*fp0Real;
Double_t f0p = f0pImag*f0pImag + f0pReal*f0pReal;
Double_t fm0 = fm0Imag*fm0Imag + fm0Real*fm0Real;
Double_t f0m = f0mImag*f0mImag + f0mReal*f0mReal;
Double_t fpm=  fpmImag*fpmImag + fpmReal*fpmReal;
Double_t fmp = fmpImag*fmpImag + fmpReal*fmpReal;

Double_t phi00=atan2(f00Imag,f00Real);
//if( isZZ ) phi00+=TMath::Pi();
Double_t phipp=atan2(fppImag,fppReal)-phi00;
Double_t phimm=atan2(fmmImag,fmmReal)-phi00;
Double_t phip0=atan2(fp0Imag,fp0Real)-phi00;
Double_t phi0p=atan2(f0pImag,f0pReal)-phi00;
Double_t phim0=atan2(fm0Imag,fm0Real)-phi00;
Double_t phi0m=atan2(f0mImag,f0mReal)-phi00;
Double_t phipm=atan2(fpmImag,fpmReal)-phi00;
Double_t phimp=atan2(fmpImag,fmpReal)-phi00;


 value += (f00*(fz0Val + fz1Val + fz2Val)*(-1 + TMath::Power(h1,2))*(-1 + TMath::Power(h2,2))*TMath::Pi())/5.;
 
 value += (fmm*(fz0Val + fz1Val + fz2Val)*TMath::Pi()*(1 + TMath::Power(h1,2) - 2*h1*R1Val)*(1 + TMath::Power(h2,2) - 2*h2*R2Val))/20.; 
 
 value += (fpp*(fz0Val + fz1Val + fz2Val)*TMath::Pi()*(1 + TMath::Power(h1,2) + 2*h1*R1Val)*(1 + TMath::Power(h2,2) + 2*h2*R2Val))/20.;
 
 value += -(fp0*(fz0Val + fz1Val + fz2Val)*(-1 + TMath::Power(h2,2))*TMath::Pi()*(1 + TMath::Power(h1,2) + 2*h1*R1Val))/10.;
 
 value += -(f0m*(fz0Val + fz1Val + fz2Val)*(-1 + TMath::Power(h1,2))*TMath::Pi()*(1 + TMath::Power(h2,2) - 2*h2*R2Val))/10.;
 
 value += -(f0p*(fz0Val + fz1Val + fz2Val)*(-1 + TMath::Power(h1,2))*TMath::Pi()*(1 + TMath::Power(h2,2) + 2*h2*R2Val))/10.;
 
 value += -(fm0*(fz0Val + fz1Val + fz2Val)*(-1 + TMath::Power(h2,2))*TMath::Pi()*(1 + TMath::Power(h1,2) - 2*h1*R1Val))/10.;
 
 value += (fpm*(fz0Val + fz1Val + fz2Val)*TMath::Pi()*(1 + TMath::Power(h1,2) + 2*h1*R1Val)*(1 + TMath::Power(h2,2) - 2*h2*R2Val))/20.;
 
 value += (fmp*(fz0Val + fz1Val + fz2Val)*TMath::Pi()*(1 + TMath::Power(h1,2) - 2*h1*R1Val)*(1 + TMath::Power(h2,2) + 2*h2*R2Val))/20.;
 
 value += (Sqrt(f00)*Sqrt(fmm)*(fz0Val + fz1Val + fz2Val)*Sqrt(1 - TMath::Power(h1,2))*Sqrt(1 - TMath::Power(h2,2))*TMath::Pi()*(h1 - R1Val)*(h2 - R2Val)*Cos(phimm - Phi))/5.;
 
 value += (Sqrt(f00)*Sqrt(fpp)*(fz0Val + fz1Val + fz2Val)*Sqrt(1 - TMath::Power(h1,2))*Sqrt(1 - TMath::Power(h2,2))*TMath::Pi()*(h1 + R1Val)*(h2 + R2Val)*Cos(phipp + Phi))/5.;
 
 value += (Sqrt(fmm)*Sqrt(fpp)*(fz0Val + fz1Val + fz2Val)*(-1 + TMath::Power(h1,2))*(-1 + TMath::Power(h2,2))*TMath::Pi()*Cos(phimm - phipp - 2*Phi))/10.;
 
 value += -(Sqrt(f0m)*Sqrt(fp0)*(fz0Val + fz1Val + fz2Val)*Sqrt(1 - TMath::Power(h1,2))*Sqrt(1 - TMath::Power(h2,2))*TMath::Pi()*(h1 + R1Val)*(h2 - R2Val)*Cos(phi0m - phip0 - Phi))/5.;
 
 value += -(Sqrt(f0p)*Sqrt(fm0)*(fz0Val + fz1Val + fz2Val)*Sqrt(1 - TMath::Power(h1,2))*Sqrt(1 - TMath::Power(h2,2))*TMath::Pi()*(h1 - R1Val)*(h2 + R2Val)*Cos(phi0p - phim0 + Phi))/5.;
 
 return value*term1Coeff*term2Coeff*betaVal;


}


Int_t RooSpinTwo_Decay::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{

if (matchArgs(allVars,analVars,RooArgSet(*h1.absArg(),*h2.absArg(),*Phi.absArg()))) return 4 ; // all integrated
if (matchArgs(allVars,analVars,h1,h2)) return 3 ; // No Phi
if (matchArgs(allVars,analVars,h1,Phi)) return 2 ; // No h2
if (matchArgs(allVars,analVars,h2,Phi)) return 1 ; // No h1
return 0 ;
}
Double_t RooSpinTwo_Decay::analyticalIntegral(Int_t code, const char* /*rangeName*/) const
{

bool isZZ = true;
if ( mZ < 90.) isZZ = false;
if ( isZZ ) {
if( (m1+m2) > mzz || m2>m1 ) return 1e-9;
} else {
if( (m1+m2) > mzz ) return 1e-9;
}
double nanval = sqrt((1 - TMath::Power(m1 - m2,2)/TMath::Power(mzz,2))*(1 - TMath::Power(m1 + m2,2)/TMath::Power(mzz,2)));
if (nanval != nanval) return 1e-9;

// set the c1->c7 terms directly from the inputs
double c1 = c1Val;
double c2 = c2Val;
double c3 = c3Val;
double c4 = c4Val;
double c5 = c5Val;
double c6 = c6Val;
double c7 = c7Val;

// calculate the c1->c7 from g
if ( useGTerm > 0. ) {
double Lambda = 1000.; // the new physics cutoff
double s = (mzz*mzz-m1*m1-m2*m2)/2.;
double kappa =  s / (Lambda*Lambda);
c1 = 2*g1Val + 2*g2Val*kappa*pow((1+mZ*mZ/s),2) + 2*g5Val*(mZ*mZ)/s;
c2 = -0.5*g1Val + g3Val*kappa*(1-mZ*mZ/s) + 2*g4Val*kappa + g7Val*kappa*mZ*mZ/s;
c3 = -1.0*(g2Val/2.0+g3Val+2.0*g4Val)*kappa*mzz*mzz/s;
c4 = -g1Val - g2Val*kappa - (g2Val+g3Val+g6Val)*kappa*(mZ*mZ/s);
c5 = 2*g8Val*kappa*(mzz*mzz)/s;
c6 = g9Val;
c7 = g10Val*kappa*(mzz*mzz)/s;
}

Double_t integral=0;
Double_t fz0Val=1-fz1Val-fz2Val;

Double_t x = (mzz*mzz-m1*m1-m2*m2)/(2.0*m1*m2);

//-----------------------------------------------------------------------
// propagator
//-----------------------------------------------------------------------

Double_t betaValSquared = (1.-(pow(m1-m2,2)/pow(mzz,2)))*(1.-(pow(m1+m2,2)/pow(mzz,2)));
Double_t betaVal = sqrt(betaValSquared);

Double_t term1Coeff = (pow(m1,3))/( (pow(m1,2)-pow(mZ,2))*(pow(m1,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );
Double_t term2Coeff = (pow(m2,3))/( (pow(m2,2)-pow(mZ,2))*(pow(m2,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );

//-----------------------------------------------------------------------
// amplitudes
// See http://www.pha.jhu.edu/~gritsan/FORM/result_spin2.txt
// -----------------------------------------------------------------------

Double_t f00Real =
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*pow(m1,3)*pow(m2,3) * ( 3./4. + (x*x-1.) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c2*pow(m1,3)*pow(m2,3) * (  - 4.*(x*x-1.) - 8.*pow(x*x-1.,2) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c3*pow(m1,3)*pow(m2,3) * (  - 8.*pow(x*x-1.,2) )

+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*m1*pow(m2,5) * (  - 1.0/2.0 - 1.0/2.0*(x*x-1.) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c2*m1*pow(m2,5) * ( 2.*(x*x-1.) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*pow(m1,5)*m2 * (  - 1.0/2.0 - 1.0/2.0*(x*x-1.) )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c2*pow(m1,5)*m2 * ( 2.*(x*x-1.) )

+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*(1.0/m1)*pow(m2,7) * ( 1.0/8.0 )
+ pow(mzz,-4)*pow(sqrt(6.),-1)*c1*pow(m1,7)*(1.0/m2) * ( 1.0/8.0 )

+ pow(sqrt(6.),-1)*c1*m1*m2 * ( 1.0/2.0 + 1.0/2.0*(x*x-1.) )
+ pow(sqrt(6.),-1)*c2*m1*m2 * (  - 2*(x*x-1.) )
+ pow(sqrt(6.),-1)*c4*m1*m2 * ( 4*(x*x-1.) )

+ pow(sqrt(6.),-1)*c1*(1.0/m1)*pow(m2,3) * (  - 1.0/4.0 )
+ pow(sqrt(6.),-1)*c1*pow(m1,3)*(1.0/m2) * (  - 1.0/4.0 )

+ pow(mzz,4)*pow(sqrt(6.),-1)*c1*(1.0/m1)*(1.0/m2) * ( 1.0/8.0 );


Double_t f00Imag = 0;

//-----------------------------------------------------------------------
Double_t fppReal =
+ pow(mzz,2)*pow(sqrt(6.),-1)*c1 * ( 1./4. )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m2,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m1,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m1,2)*pow(m2,2) * ( 1.0/2.0 + (x*x-1.) )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c2*pow(m1,2)*pow(m2,2) * ( 8*(x*x-1.) );

Double_t fppImag =

+ 1*pow(mzz,-4)*pow(sqrt(6.),-1)*c5*pow(m1,3)*pow(m2,3) * ( 8*pow(sqrt(x*x-1.),3) )

+ 1*pow(sqrt(6.),-1)*c6*m1*m2 * (  - 4*sqrt(x*x-1.) );

//-----------------------------------------------------------------------
Double_t fmmReal =
+ pow(mzz,2)*pow(sqrt(6.),-1)*c1 * ( 1.0/4.0 )

+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m1,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m2,4) * (  - 1.0/4.0 )

+ pow(mzz,-2)*pow(sqrt(6.),-1)*c1*pow(m1,2)*pow(m2,2) * ( 1.0/2.0 + (x*x-1.) )
+ pow(mzz,-2)*pow(sqrt(6.),-1)*c2*pow(m1,2)*pow(m2,2) * ( 8*(x*x-1.) );

Double_t fmmImag =

+ 1*pow(mzz,-4)*pow(sqrt(6.),-1)*c5*pow(m1,3)*pow(m2,3) * (  - 8*pow(sqrt(x*x-1.),3) )

+ 1*pow(sqrt(6.),-1)*c6*m1*m2 * ( 4*sqrt(x*x-1.) );

//-----------------------------------------------------------------------

Double_t fp0Real =

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m2,5) * (  - 1.0/8.0 )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,2)*pow(m2,3) * ( 3.0/8.0 + 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,4)*m2 * (  - 3.0/8.0 - 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,6)*(1.0/m2) * ( 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,2)*m2 * ( 1.0/4.0 + 1.0/2.0*(x*x-1.) )
+ (1.0/mzz)*(1.0/sqrt(2.))*c4*pow(m1,2)*m2 * ( 2.*(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m2,3) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,4)*(1.0/m2) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*m2 * ( 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*pow(m1,2)*(1.0/m2) * (  - 1.0/8.0 )

+ pow(mzz,3)*(1.0/sqrt(2.))*c1*(1.0/m2) * ( 1.0/8.0 );

Double_t fp0Imag =

+ 1*(1.0/pow(mzz,3))*(1.0/sqrt(2.))*pow(m1,3)*pow(m2,2) * (  - 4*pow(sqrt(x*x-1.),3)*c7 )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*m1*pow(m2,2) * (  - sqrt(x*x-1.) )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m1,3) * ( sqrt(x*x-1.) )

+ 1*mzz*(1.0/sqrt(2.))*c6*m1 * (  - sqrt(x*x-1.) );



//-----------------------------------------------------------------------
Double_t f0pReal =
+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,6) * ( 1.0/8.0 )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*m1*pow(m2,4) * (  - 3.0/8.0 - 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,3)*pow(m2,2) * ( 3.0/8.0 + 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,5) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*m1*pow(m2,2) * ( 1.0/4.0 + 1.0/2.0*(x*x-1.) )
+ (1.0/mzz)*(1.0/sqrt(2.))*c4*m1*pow(m2,2) * ( 2*(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,4) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,3) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,2) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*m1 * ( 1.0/8.0 )

+ pow(mzz,3)*(1.0/sqrt(2.))*c1*(1.0/m1) * ( 1.0/8.0 );

Double_t f0pImag =

+ 1*(1.0/pow(mzz,3))*(1.0/sqrt(2.))*pow(m1,2)*pow(m2,3) * (  - 4*pow(sqrt(x*x-1.),3)*c7 )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m2,3) * ( sqrt(x*x-1.) )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m1,2)*m2 * (  - sqrt(x*x-1.) )

+ 1*mzz*(1.0/sqrt(2.))*c6*m2 * (  - sqrt(x*x-1.) );

//-----------------------------------------------------------------------


Double_t f0mReal =
+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,6) * ( 1.0/8.0 )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*m1*pow(m2,4) * (  - 3.0/8.0 - 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,3)*pow(m2,2) * ( 3.0/8.0 + 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,5) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*m1*pow(m2,2) * ( 1.0/4.0 + 1.0/2.0*(x*x-1.) )
+ (1.0/mzz)*(1.0/sqrt(2.))*c4*m1*pow(m2,2) * ( 2*(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,4) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,3) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*(1.0/m1)*pow(m2,2) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*m1 * ( 1.0/8.0 )

+ pow(mzz,3)*(1.0/sqrt(2.))*c1*(1.0/m1) * ( 1.0/8.0 );

Double_t f0mImag =

+ 1*(1.0/pow(mzz,3))*(1.0/sqrt(2.))*pow(m1,2)*pow(m2,3) * ( 4*pow(sqrt(x*x-1.),3)*c7 )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m2,3) * (  - sqrt(x*x-1.) )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m1,2)*m2 * ( sqrt(x*x-1.) )

+ 1*mzz*(1.0/sqrt(2.))*c6*m2 * ( sqrt(x*x-1.) );

//-----------------------------------------------------------------------

Double_t fm0Real =
+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m2,5) * (  - 1.0/8.0 )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,2)*pow(m2,3) * ( 3.0/8.0 + 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,4)*m2 * (  - 3.0/8.0 - 1.0/2.0*(x*x-1.) )

+ (1.0/pow(mzz,3))*(1.0/sqrt(2.))*c1*pow(m1,6)*(1.0/m2) * ( 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,2)*m2 * ( 1.0/4.0 + 1.0/2.0*(x*x-1.) )
+ (1.0/mzz)*(1.0/sqrt(2.))*c4*pow(m1,2)*m2 * ( 2*(x*x-1.) )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m2,3) * (  - 1.0/8.0 )

+ (1.0/mzz)*(1.0/sqrt(2.))*c1*pow(m1,4)*(1.0/m2) * (  - 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*m2 * ( 1.0/8.0 )

+ mzz*(1.0/sqrt(2.))*c1*pow(m1,2)*(1.0/m2) * (  - 1.0/8.0 )

+ pow(mzz,3)*(1.0/sqrt(2.))*c1*(1.0/m2) * ( 1.0/8.0 );

Double_t fm0Imag =

+ 1*(1.0/pow(mzz,3))*(1.0/sqrt(2.))*pow(m1,3)*pow(m2,2) * ( 4*pow(sqrt(x*x-1.),3)*c7 )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*m1*pow(m2,2) * ( sqrt(x*x-1.) )

+ 1*(1.0/mzz)*(1.0/sqrt(2.))*c6*pow(m1,3) * (  - sqrt(x*x-1.) )

+ 1*mzz*(1.0/sqrt(2.))*c6*m1 * ( sqrt(x*x-1.) );

//-----------------------------------------------------------------------
Double_t fpmReal =
+ pow(mzz,-2)*c1*pow(m1,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*c1*pow(m2,4) * (  - 1.0/4.0 )

+ pow(mzz,-2)*c1*pow(m1,2)*pow(m2,2) * ( 1.0/2.0 + (x*x-1.) )

+ pow(mzz,2)*c1 * ( 1.0/4.0 );

Double_t fpmImag = 0;

//-----------------------------------------------------------------------

Double_t fmpReal =
+ pow(mzz,-2)*c1*pow(m2,4) * (  - 1.0/4.0 )
+ pow(mzz,-2)*c1*pow(m1,4) * (  - 1.0/4.0 )

+ pow(mzz,-2)*c1*pow(m1,2)*pow(m2,2) * ( 1.0/2.0 + (x*x-1.) )

+ pow(mzz,2)*c1 * ( 1.0/4.0 );

Double_t fmpImag = 0;

//-----------------------------------------------------------------------
Double_t f00 = f00Imag*f00Imag + f00Real*f00Real;
Double_t fpp = fppImag*fppImag + fppReal*fppReal;
Double_t fmm = fmmImag*fmmImag + fmmReal*fmmReal;
Double_t fp0 = fp0Imag*fp0Imag + fp0Real*fp0Real;
Double_t f0p = f0pImag*f0pImag + f0pReal*f0pReal;
Double_t fm0 = fm0Imag*fm0Imag + fm0Real*fm0Real;
Double_t f0m = f0mImag*f0mImag + f0mReal*f0mReal;
Double_t fpm=  fpmImag*fpmImag + fpmReal*fpmReal;
Double_t fmp = fmpImag*fmpImag + fmpReal*fmpReal;

Double_t phi00=atan2(f00Imag,f00Real);
//if( isZZ ) phi00+=TMath::Pi();
Double_t phipp=atan2(fppImag,fppReal)-phi00;
Double_t phimm=atan2(fmmImag,fmmReal)-phi00;
Double_t phip0=atan2(fp0Imag,fp0Real)-phi00;
Double_t phi0p=atan2(f0pImag,f0pReal)-phi00;
Double_t phim0=atan2(fm0Imag,fm0Real)-phi00;
Double_t phi0m=atan2(f0mImag,f0mReal)-phi00;
Double_t phipm=atan2(fpmImag,fpmReal)-phi00;
Double_t phimp=atan2(fmpImag,fmpReal)-phi00;

//-----------------------------------------------------------------------

switch(code)
{
// integrate all angles
case 4:
{

double value=0;

value += (32*f00*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2))/45.;

value += (32*fmm*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2))/45.;

value += (32*fpp*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2))/45.;

value += (32*fp0*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2))/45.;

value += (32*f0m*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2))/45.;

value += (32*f0p*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2))/45.;

value += (32*fm0*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2))/45.;

value += (32*fpm*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2))/45.;

value += (32*fmp*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2))/45.;



integral = value;
return term1Coeff*term2Coeff*betaVal*integral;
}

// projection to Phi, integrate all other angles
case 3:
{

double value=0;

value += (16*f00*(fz0Val + fz1Val + fz2Val)*Pi())/45.;

value += (16*fmm*(fz0Val + fz1Val + fz2Val)*Pi())/45.;

value += (16*fpp*(fz0Val + fz1Val + fz2Val)*Pi())/45.;

value += (16*fp0*(fz0Val + fz1Val + fz2Val)*Pi())/45.;

value += (16*f0m*(fz0Val + fz1Val + fz2Val)*Pi())/45.;

value += (16*f0p*(fz0Val + fz1Val + fz2Val)*Pi())/45.;

value += (16*fm0*(fz0Val + fz1Val + fz2Val)*Pi())/45.;

value += (16*fpm*(fz0Val + fz1Val + fz2Val)*Pi())/45.;

value += (16*fmp*(fz0Val + fz1Val + fz2Val)*Pi())/45.;

value += (sqrt(f00)*sqrt(fmm)*(fz0Val + fz1Val + fz2Val)*Power(Pi(),3)*R1Val*R2Val*Cos(Phi - phimm))/20.;

value += (sqrt(f00)*sqrt(fpp)*(fz0Val + fz1Val + fz2Val)*Power(Pi(),3)*R1Val*R2Val*Cos(Phi + phipp))/20.;

value += (8*sqrt(fmm)*sqrt(fpp)*(fz0Val + fz1Val + fz2Val)*Pi()*Cos(2*Phi - phimm + phipp))/45.;

value += (sqrt(f0m)*sqrt(fp0)*(fz0Val + fz1Val + fz2Val)*Power(Pi(),3)*R1Val*R2Val*Cos(Phi - phi0m + phip0))/20.;

value += (sqrt(f0p)*sqrt(fm0)*(fz0Val + fz1Val + fz2Val)*Power(Pi(),3)*R1Val*R2Val*Cos(Phi + phi0p - phim0))/20.;


integral = value;
return term1Coeff*term2Coeff*betaVal*integral;

}
// projections to h2, integrate over all others
case 2:
{

double value=0;

value += (-8*f00*(fz0Val + fz1Val + fz2Val)*(-1 + Power(h2,2))*Power(Pi(),2))/15.;

value += (-4*fmm*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(-1 - Power(h2,2) + 2*h2*R2Val))/15.;

value += (4*fpp*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(1 + Power(h2,2) + 2*h2*R2Val))/15.;

value += (-8*fp0*(fz0Val + fz1Val + fz2Val)*(-1 + Power(h2,2))*Power(Pi(),2))/15.;

value += (-4*f0m*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(-1 - Power(h2,2) + 2*h2*R2Val))/15.;

value += (4*f0p*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(1 + Power(h2,2) + 2*h2*R2Val))/15.;

value += (-8*fm0*(fz0Val + fz1Val + fz2Val)*(-1 + Power(h2,2))*Power(Pi(),2))/15.;

value += (-4*fpm*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(-1 - Power(h2,2) + 2*h2*R2Val))/15.;

value += (4*fmp*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(1 + Power(h2,2) + 2*h2*R2Val))/15.;


integral = value;
return term1Coeff*term2Coeff*betaVal*integral;
}

// projections to h1, integrate all others
case 1:
{

double value=0;

value += (-8*f00*(fz0Val + fz1Val + fz2Val)*(-1 + Power(h1,2))*Power(Pi(),2))/15.;

value += (-4*fmm*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(-1 - Power(h1,2) + 2*h1*R1Val))/15.;

value += (4*fpp*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(1 + Power(h1,2) + 2*h1*R1Val))/15.;

value += (4*fp0*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(1 + Power(h1,2) + 2*h1*R1Val))/15.;

value += (-8*f0m*(fz0Val + fz1Val + fz2Val)*(-1 + Power(h1,2))*Power(Pi(),2))/15.;

value += (-8*f0p*(fz0Val + fz1Val + fz2Val)*(-1 + Power(h1,2))*Power(Pi(),2))/15.;

value += (-4*fm0*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(-1 - Power(h1,2) + 2*h1*R1Val))/15.;

value += (4*fpm*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(1 + Power(h1,2) + 2*h1*R1Val))/15.;

value += (-4*fmp*(fz0Val + fz1Val + fz2Val)*Power(Pi(),2)*(-1 - Power(h1,2) + 2*h1*R1Val))/15.;


 integral = value;
 return betaVal*term1Coeff*term2Coeff*integral;
 }
}
 assert(0) ;
 return 0 ;
}

