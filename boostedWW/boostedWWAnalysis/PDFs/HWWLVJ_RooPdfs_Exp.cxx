/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "HWWLVJ_RooPdfs_Exp.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

Double_t ErfExp(Double_t x, Double_t c, Double_t offset, Double_t width){
	//return TMath::Exp(c*x)*(1.+TMath::Erf((x-offset)/width))/2. ;
    if (c==0)c=0.0000001;
	return TMath::Exp(c*x) ;
}

Double_t ErfExp(Double_t x, Double_t x_min, Double_t x_max, Double_t c, Double_t offset, Double_t width){
/*	double minTerm = (TMath::Exp(c*c*width*width/4+c*offset) * 
					TMath::Erf((2*x_min-c*width*width-
							2*offset)/2/width) - 
					TMath::Exp(c*x_min) * 
					TMath::Erf((x_min-offset)/width) - 
					TMath::Exp(c*x_min))/-2/c;
	double maxTerm = (TMath::Exp(c*c*width*width/4+c*offset) * 
					TMath::Erf((2*x_max-c*width*width-
							2*offset)/2/width) - 
					TMath::Exp(c*x_max) * 
					TMath::Erf((x_max-offset)/width) - 
					TMath::Exp(c*x_max))/-2/c;
	Double_t integral=(maxTerm-minTerm) ;
	return TMath::Exp(c*x)*(1.+TMath::Erf((x-offset)/width))/2./integral ; */
    if (c==0)c=0.0000001;
    return TMath::Exp(c*x)*c/(TMath::Exp(c*x_max)-TMath::Exp(c*x_min) );
}

ClassImp(RooErfExpPdf) 

RooErfExpPdf::RooErfExpPdf(const char *name, const char *title, 
					RooAbsReal& _x,
					RooAbsReal& _c,
					RooAbsReal& _offset,
					RooAbsReal& _width) :
			RooAbsPdf(name,title), 
			x("x","x",this,_x),
			c("c","c",this,_c),
			offset("offset","offset",this,_offset),
			width("width","width",this,_width)
{ 
} 


RooErfExpPdf::RooErfExpPdf(const RooErfExpPdf& other, const char* name) :  
	RooAbsPdf(other,name), 
	x("x",this,other.x),
	c("c",this,other.c),
	offset("offset",this,other.offset),
	width("width",this,other.width)
{ 
} 



Double_t RooErfExpPdf::evaluate() const 
{ 
	// ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
	// return TMath::Exp(c*x)*(1.+TMath::Erf((x-offset)/width))/2. ; 
	return ErfExp(x,c,offset,width) ; 
} 

Int_t RooErfExpPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
{ 
	// LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
	// ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
	// THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
	// YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
	// EXPRESSION MULTIPLE TIMES

	if (matchArgs(allVars,analVars,x)) return 1 ; 
	return 0 ; 
} 

Double_t RooErfExpPdf::analyticalIntegral(Int_t code, const char* rangeName) const  
{ 
	// RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
	// THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
	// BOUNDARIES FOR EACH OBSERVABLE x

	if (code==1) { 
        Double_t minTerm=0;
        Double_t maxTerm=0;
        if(c==0){ 
            Double_t delta=-0.0000001;
            minTerm = TMath::Exp(c*x.min(rangeName))/delta;
		    maxTerm = TMath::Exp(c*x.max(rangeName))/delta;
        }else{
            minTerm = TMath::Exp(c*x.min(rangeName))/c;
		    maxTerm = TMath::Exp(c*x.max(rangeName))/c;
        }

		return (maxTerm-minTerm) ;
        //return (TMath::Exp(c*x.max(rangeName))-TMath::Exp(c*x.min(rangeName)) )/c;
	} 
	return 0 ; 
} 

ClassImp(RooAlpha)

RooAlpha::RooAlpha(){}

RooAlpha::RooAlpha(const char *name, const char *title,
		   RooAbsReal& _x,
		   RooAbsReal& _c,
		   RooAbsReal& _offset,
		   RooAbsReal& _width,
		   RooAbsReal& _ca,
		   RooAbsReal& _offseta,
		   RooAbsReal& _widtha,
           Double_t _xmin,
           Double_t _xmax
	     ) :
  RooAbsPdf(name,title),
  x("x","x",this,_x),
  c("c","c",this,_c),
  offset("offset","offset",this,_offset),
  width("width","width",this,_width),
  ca("ca","ca",this,_ca),
  offseta("offseta","offseta",this,_offseta),
  widtha("widtha","widtha",this,_widtha)
{
        xmin=_xmin;
        xmax=_xmax;
}

RooAlpha::RooAlpha(const RooAlpha& other, const char* name) :
  RooAbsPdf(other,name),
  x("x",this,other.x),
  c("c",this,other.c),
  offset("offset",this,other.offset),
  width("width",this,other.width),
  ca("ca",this,other.ca),
  offseta("offseta",this,other.offseta),
  widtha("widtha",this,other.widtha)
{
        xmin=other.xmin;
        xmax=other.xmax;
}

double RooAlpha::evaluate() const
{
  //return ErfExp(x,c,offset,width)/ErfExp(x,ca,offseta,widtha);
  //cout<<"alpha="<<ErfExp(x,xmin,xmax,c,offset,width)/ErfExp(x,xmin,xmax,ca,offseta,widtha)<<endl;
  //cout<<"x={"<<x<<","<<xmin<<","<<xmax<<endl;
  //cout<<"Erf={"<<ErfExp(x,xmin,xmax,c,offset,width)<<","<<ErfExp(x,xmin,xmax,ca,offseta,widtha)<<endl;
  //cout<<c<<","<<offset<<","<<width<<","<<ca<<","<<offseta<<","<<widtha<<endl;
  return ErfExp(x,xmin,xmax,c,offset,width)/ErfExp(x,xmin,xmax,ca,offseta,widtha);
}


