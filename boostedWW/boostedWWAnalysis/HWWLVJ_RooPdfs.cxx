/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "HWWLVJ_RooPdfs.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include "RooExponential.h" 
#include <math.h> 
#include "TMath.h" 

Double_t ErfExp(Double_t x, Double_t c, Double_t offset, Double_t width){
	return TMath::Exp(c*x)*(1.+TMath::Erf((x-offset)/width))/2. ;
}

Double_t ErfExp(Double_t x, Double_t x_min, Double_t x_max, Double_t c, Double_t offset, Double_t width){
	double minTerm = (TMath::Exp(c*c*width*width/4+c*offset) * 
					TMath::Erf((2*x_min-c*width*width-
							2*offset)/2/width) - 
					TMath::Exp(c*x_min) * 
					TMath::Erf((x_min-offset)/width) - 
					TMath::Exp(c*x_min))/-2/c;
	double maxTerm = (TMath::Exp(c*c*width*width/4+c*offset) * 
					TMath::Erf((2*x_max-c*width*width-
							2*offset)/2/width) - 
					TMath::Exp(c*x_max) * 
					TMath::Erf((x_max-offset)/width) - 
					TMath::Exp(c*x_max))/-2/c;
	Double_t integral=(maxTerm-minTerm) ;
	return TMath::Exp(c*x)*(1.+TMath::Erf((x-offset)/width))/2./integral ;
}


Double_t Exp(Double_t x, Double_t c){
	return TMath::Exp(c*x);
}

Double_t Exp(Double_t x, Double_t x_min, Double_t x_max, Double_t c){
	Double_t integral ;
    if(c==0.){
        integral=x_max-x_min;
    }else{
        integral= ( TMath::Exp(c*x_max)-TMath::Exp(c*x_min) ) / c;
    }
	return TMath::Exp(c*x)/integral ;
}

ClassImp(RooErfExpPdf) 

RooErfExpPdf::RooErfExpPdf(const char *name, const char *title, 
					RooAbsReal& _x,
					RooAbsReal& _c,
					RooAbsReal& _offset,
					RooAbsReal& _width) :
			RooAbsPdf(name,title), 
			x("x","x",this,_x),
			c("c","c",this,_c),
			offset("offset","offset",this,_offset),
			width("width","width",this,_width)
{ 
} 


RooErfExpPdf::RooErfExpPdf(const RooErfExpPdf& other, const char* name) :  
	RooAbsPdf(other,name), 
	x("x",this,other.x),
	c("c",this,other.c),
	offset("offset",this,other.offset),
	width("width",this,other.width)
{ 
} 



Double_t RooErfExpPdf::evaluate() const 
{ 
	// ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
	// return TMath::Exp(c*x)*(1.+TMath::Erf((x-offset)/width))/2. ; 
	return ErfExp(x,c,offset,width) ; 
} 

Int_t RooErfExpPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
{ 
	// LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
	// ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
	// THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
	// YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
	// EXPRESSION MULTIPLE TIMES

	if (matchArgs(allVars,analVars,x)) return 1 ; 
	return 0 ; 
} 

Double_t RooErfExpPdf::analyticalIntegral(Int_t code, const char* rangeName) const  
{ 
	// RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
	// THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
	// BOUNDARIES FOR EACH OBSERVABLE x

	if (code==1) { 
        Double_t minTerm=0;
        Double_t maxTerm=0;
        if(c==0){ 
            Double_t delta=-0.0000001;
            minTerm = (TMath::Exp(delta*delta*width*width/4+delta*offset) * 
					TMath::Erf((2*x.min(rangeName)-delta*width*width-
							2*offset)/2/width) - 
					TMath::Exp(delta*x.min(rangeName)) * 
					TMath::Erf((x.min(rangeName)-offset)/width) - 
					TMath::Exp(delta*x.min(rangeName)))/-2/delta;
		    maxTerm = (TMath::Exp(delta*delta*width*width/4+delta*offset) * 
					TMath::Erf((2*x.max(rangeName)-delta*width*width-
							2*offset)/2/width) - 
					TMath::Exp(delta*x.max(rangeName)) * 
					TMath::Erf((x.max(rangeName)-offset)/width) - 
					TMath::Exp(delta*x.max(rangeName)))/-2/delta;
        
        }else{
            minTerm = (TMath::Exp(c*c*width*width/4+c*offset) * 
					TMath::Erf((2*x.min(rangeName)-c*width*width-
							2*offset)/2/width) - 
					TMath::Exp(c*x.min(rangeName)) * 
					TMath::Erf((x.min(rangeName)-offset)/width) - 
					TMath::Exp(c*x.min(rangeName)))/-2/c;
		    maxTerm = (TMath::Exp(c*c*width*width/4+c*offset) * 
					TMath::Erf((2*x.max(rangeName)-c*width*width-
							2*offset)/2/width) - 
					TMath::Exp(c*x.max(rangeName)) * 
					TMath::Erf((x.max(rangeName)-offset)/width) - 
					TMath::Exp(c*x.max(rangeName)))/-2/c;
        }

		// std::cout << "c: " << c << " offset: " << offset << " width: " << width
		// 	       << '\n'
		// 	       << "maxTerm - minTerm: " << maxTerm << " - " 
		// 	       << minTerm << '\n'
		// 	       << "integral: " << (maxTerm-minTerm) << '\n';
        //cout<<"maxTerm="<<maxTerm<<endl;
        //cout<<"minTerm="<<minTerm<<endl;
        //cout<< c<<","<< width<<","<< offset<<","<< x.min(rangeName)<<","<< x.max(rangeName)<<"\n";
		return (maxTerm-minTerm) ;
	} 
	return 0 ; 
} 

ClassImp(RooAlpha)

RooAlpha::RooAlpha(){}

RooAlpha::RooAlpha(const char *name, const char *title,
		   RooAbsReal& _x,
		   RooAbsReal& _c,
		   RooAbsReal& _offset,
		   RooAbsReal& _width,
		   RooAbsReal& _ca,
		   RooAbsReal& _offseta,
		   RooAbsReal& _widtha,
           Double_t _xmin,
           Double_t _xmax
	     ) :
  RooAbsPdf(name,title),
  x("x","x",this,_x),
  c("c","c",this,_c),
  offset("offset","offset",this,_offset),
  width("width","width",this,_width),
  ca("ca","ca",this,_ca),
  offseta("offseta","offseta",this,_offseta),
  widtha("widtha","widtha",this,_widtha)
{
        xmin=_xmin;
        xmax=_xmax;
}

RooAlpha::RooAlpha(const RooAlpha& other, const char* name) :
  RooAbsPdf(other,name),
  x("x",this,other.x),
  c("c",this,other.c),
  offset("offset",this,other.offset),
  width("width",this,other.width),
  ca("ca",this,other.ca),
  offseta("offseta",this,other.offseta),
  widtha("widtha",this,other.widtha)
{
        xmin=other.xmin;
        xmax=other.xmax;
}

double RooAlpha::evaluate() const
{
  return ErfExp(x,xmin,xmax,c,offset,width)/ErfExp(x,xmin,xmax,ca,offseta,widtha);
}



ClassImp(RooAlpha)

RooAlphaExp::RooAlphaExp(){}

RooAlphaExp::RooAlphaExp(const char *name, const char *title,
		   RooAbsReal& _x,
		   RooAbsReal& _c,
		   RooAbsReal& _ca,
           Double_t _xmin,
           Double_t _xmax
	     ) :
  RooAbsPdf(name,title),
  x("x","x",this,_x),
  c("c","c",this,_c),
  ca("ca","ca",this,_ca)
{
        xmin=_xmin;
        xmax=_xmax;
}

RooAlphaExp::RooAlphaExp(const RooAlphaExp& other, const char* name) :
  RooAbsPdf(other,name),
  x("x",this,other.x),
  c("c",this,other.c),
  ca("ca",this,other.ca)
{
        xmin=other.xmin;
        xmax=other.xmax;
}

double RooAlphaExp::evaluate() const
{
  return Exp(x,xmin,xmax,c)/Exp(x,xmin,xmax,ca);
}

